# Tutorial Prático: InversifyJS do Zero

Este guia ensina como configurar um projeto TypeScript com Injeção de Dependência usando **InversifyJS**.

**Cenário do Exemplo:** Um sistema de processamento de pagamentos onde precisamos trocar facilmente entre provedores (ex: PayPal vs Stripe) sem alterar a regra de negócio.

---

## 1. Preparação do Ambiente

Abra seu terminal na pasta onde deseja criar o projeto e execute os comandos abaixo sequencialmente:

```bash
# 1. Cria e entra na pasta do projeto
mkdir projeto-inversify
cd projeto-inversify

# 2. Inicia o package.json com valores padrão
npm init -y

# 3. Instala as dependências de produção
# 'reflect-metadata' é obrigatório para o Inversify funcionar
npm install inversify reflect-metadata

# 4. Instala as dependências de desenvolvimento (TypeScript e executor)
npm install typescript ts-node @types/node --save-dev
```

---

## 2. Configuração do TypeScript

O Inversify depende de *Decorators* e metadados. Precisamos configurar o `tsconfig.json`.

1. Gere o arquivo de configuração:
```bash
npx tsc --init
```

2. Abra o arquivo `tsconfig.json` gerado e certifique-se de que as propriedades abaixo estão ativas (`true`) e descomentadas:

```json
{
  "compilerOptions": {
    "module": "commonjs",
    "moduleResolution": "node",
    "target": "ES2023",
    "strict": true,
    "esModuleInterop": true,
    "ignoreDeprecations": "6.0",

    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,

    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true,

    "jsx": "react-jsx",
    "verbatimModuleSyntax": false,
    "isolatedModules": false,
    "noUncheckedSideEffectImports": true,
    "moduleDetection": "force",
    "skipLibCheck": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "types": ["reflect-metadata"],
    "outDir": "./dist",
    "rootDir": "./src",
  }
}

```

---

## 3. Implementação do Código

Crie uma pasta chamada `src` na raiz do projeto. Todos os arquivos abaixo ficarão dentro de `src/`.

### 3.1. Identificadores de Dependência (`src/types.ts`)
Como o TypeScript remove as Interfaces após a compilação, o Inversify usa `Symbols` para identificar o que deve ser injetado.

```typescript
// src/types.ts
const TYPES = {
    PaymentProcessor: Symbol.for("PaymentProcessor"),
    Notifier: Symbol.for("Notifier"),
    CheckoutService: Symbol.for("CheckoutService")
};

export { TYPES };
```

### 3.2. Contratos / Interfaces (`src/interfaces.ts`)
Definimos **o que** o sistema faz, mas não **como** ele faz.

```typescript
// src/interfaces.ts
export interface IPaymentProcessor {
    process(amount: number): boolean;
}

export interface INotifier {
    send(message: string): void;
}
```

### 3.3. Implementações Concretas (`src/implementations.ts`)
Aqui criamos a lógica real. Note que usamos o decorator `@injectable()` para permitir que o Inversify gerencie essas classes.

```typescript
// src/implementations.ts

import { injectable } from "inversify";
import type { INotifier, IPaymentProcessor } from "./interfaces";

// --- Opção A: PayPal ---
@injectable()
export class PayPalProcessor implements IPaymentProcessor {
    process(amount: number): boolean {
        console.log(`[PayPal] Processando pagamento de R$ ${amount}...`);
        return true; 
    }
}

// --- Opção B: Stripe (Para testarmos a troca depois) ---
@injectable()
export class StripeProcessor implements IPaymentProcessor {
    process(amount: number): boolean {
        console.log(`[Stripe] Cartão debitado: R$ ${amount}`);
        return true;
    }
}

// --- Notificador Simples ---
@injectable()
export class ConsoleNotifier implements INotifier {
    send(message: string): void {
        console.log(`[Notificação]: ${message}`);
    }
}
```

### 3.4. Regra de Negócio (`src/checkout-service.ts`)
O serviço de checkout. Ele **não sabe** se estamos usando PayPal ou Stripe. Ele apenas pede um `PaymentProcessor` ao container.

```typescript
// src/checkout-service.ts
import { injectable, inject } from "inversify";
import { TYPES } from "./types";
import { INotifier, IPaymentProcessor } from "./interfaces";

@injectable()
export class CheckoutService {
    
    constructor(
        // Injetamos as dependências usando os Symbols definidos em types.ts
        @inject(TYPES.PaymentProcessor) private paymentSystem: IPaymentProcessor,
        @inject(TYPES.Notifier) private notifier: INotifier
    ) {}

    public purchase(product: string, price: number): void {
        console.log(`--- Iniciando compra de: ${product} ---`);
        
        const success = this.paymentSystem.process(price);

        if (success) {
            this.notifier.send(`Recibo enviado para o cliente.`);
        } else {
            this.notifier.send(`Erro na compra.`);
        }
    }
}
```

### 3.5. O Container IoC (`src/inversify.config.ts`)
Este é o arquivo de configuração ("Wiring"). Aqui decidimos quais peças o sistema vai usar.

```typescript
// src/inversify.config.ts
import { Container } from "inversify";
import { TYPES } from "./types";
import { IPaymentProcessor, INotifier } from "./interfaces";
import { CheckoutService } from "./checkout-service";
import { ConsoleNotifier, PayPalProcessor, StripeProcessor } from "./implementations";

const container = new Container();

// CONFIGURAÇÃO:
// Aqui está a "mágica". Se quisermos trocar de Stripe para PayPal,
// alteramos APENAS esta linha:
container.bind<IPaymentProcessor>(TYPES.PaymentProcessor).to(StripeProcessor);
// container.bind<IPaymentProcessor>(TYPES.PaymentProcessor).to(PayPalProcessor);

// As outras dependências
container.bind<INotifier>(TYPES.Notifier).to(ConsoleNotifier);
container.bind<CheckoutService>(TYPES.CheckoutService).to(CheckoutService);

export { container };
```

### 3.6. Ponto de Entrada (`src/index.ts`)

```typescript
// src/index.ts
import "reflect-metadata"; // IMPORTANTE: 1ª linha obrigatória
import { container } from "./inversify.config";
import { TYPES } from "./types";
import { CheckoutService } from "./checkout-service";

function main() {
    // Pedimos ao container o serviço pronto
    const checkout = container.get<CheckoutService>(TYPES.CheckoutService);

    // Usamos o serviço
    checkout.purchase("Notebook Gamer", 4500);
}

main();
```

---

## 4. Executando o Projeto

Para rodar o código, use o comando abaixo no terminal:

```bash
npx ts-node src/index.ts
```

**Saída esperada:**
```text
--- Iniciando compra de: Notebook Gamer ---
[Stripe] Cartão debitado: R$ 4500
[Notificação]: Recibo enviado para o cliente.
```

---

## 5. Demonstração de Desacoplamento

Para provar o valor do IoC Container, vamos trocar o provedor de pagamento de **Stripe** para **PayPal** sem tocar na lógica de negócios (`CheckoutService`).

1. Abra o arquivo `src/inversify.config.ts`.
2. Altere a linha do binding:

**De:**
```typescript
container.bind<IPaymentProcessor>(TYPES.PaymentProcessor).to(StripeProcessor);
```

**Para:**
```typescript
container.bind<IPaymentProcessor>(TYPES.PaymentProcessor).to(PayPalProcessor);
```

3. Execute novamente:
```bash
npx ts-node src/index.ts
```

**Nova Saída:**
```text
--- Iniciando compra de: Notebook Gamer ---
[PayPal] Processando pagamento de R$ 4500...
[Notificação]: Recibo enviado para o cliente.
```

**Conclusão:** Alteramos o comportamento central do sistema mudando apenas uma linha de configuração no Container.
