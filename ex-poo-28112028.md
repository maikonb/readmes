# Exercício 1 – Estacionamento com veículos, enum de tipo e estratégias de preço

Implemente um sistema de estacionamento com:

- `enum VehicleType`  
  - Valores: `CAR`, `MOTORCYCLE`, `TRUCK`.

- `abstract class Vehicle`  
  - Propriedades: `plate: string`, `type: VehicleType`  
  - Método abstrato: `getBasePricePerHour(): number`.

- Subclasses: `Car`, `Motorcycle`, `Truck`  
  - Cada uma define um preço base por hora em um atributo estático.  
  - Métodos estáticos: `setBasePricePerHour(value: number)` e `getBasePricePerHourConfig(): number`.  
  - Implementam `getBasePricePerHour()` retornando o valor estático configurado.

- `class ParkingSpot`  
  - Propriedades: `id: string`, `allowedType: VehicleType`.  
  - Guarda um `vehicle: Vehicle | null`.  
  - Métodos:  
    - `isFree(): boolean`  
    - `park(vehicle: Vehicle): boolean` (só estaciona se estiver livre e `vehicle.type === allowedType`)  
    - `leave(): Vehicle | null`.

- `interface PricingStrategy`  
  - Método: `calculate(vehicle: Vehicle, hours: number): number`.

- Implemente pelo menos 3 estratégias:  
  - `FlatRatePricing` (cobra horas arredondadas × preço base).  
  - `ProgressivePricing` (primeiras N horas preço normal, depois fator maior).  
  - `OvernightPricing` (acima de certo número de horas, aplica tarifa noturna especial).

- `class ParkingLot`  
  - Mantém uma lista de `ParkingSpot`.  
  - Métodos:  
    - `addSpot(spot: ParkingSpot)`  
    - `findFreeSpotFor(vehicle: Vehicle): ParkingSpot | undefined`  
    - `park(vehicle: Vehicle): ParkingSpot | undefined`  
    - `leaveFromSpot(id: string): Vehicle | null`  
    - `calculateFee(vehicle: Vehicle, hours: number, strategy: PricingStrategy): number`.

- Exemplo de uso:  
  - Configure preços base para `Car`, `Motorcycle` e `Truck`.  
  - Crie algumas vagas para cada tipo.  
  - Estacione veículos diferentes e calcule o valor usando as três estratégias de preço para comparar.

---

# Exercício 2 – Inventário de produtos com itens e pacotes (Composite + Generics)

Implemente um inventário de produtos com produtos unitários, pacotes e uso de generics com diferentes tipos concretos:

- `interface PricedItem`  
  - Método: `getPrice(): number`.

- `class SingleProduct implements PricedItem`  
  - Propriedades: `name`, `basePrice`.  
  - `getPrice()` retorna `basePrice`.

- `class Bundle implements PricedItem` (Composite)  
  - Propriedade: `name`.  
  - Lista interna de itens: `{ item: PricedItem; quantity: number }[]`.  
  - Métodos:  
    - `addItem(item: PricedItem, quantity: number)`.  
    - `getPrice()` somando `item.getPrice() * quantity` para todos os itens.  
  - Atributo estático: `globalDiscount: number` (0–1) aplicado ao total.  
  - Método estático: `setGlobalDiscount(discount: number)`.

- `class Inventory<T extends PricedItem>`  
  - Estrutura interna: por exemplo, `Map<T, number>`.  
  - Métodos:  
    - `add(item: T, quantity: number)`.  
    - `remove(item: T, quantity: number)`.  
    - `getQuantity(item: T): number`.  
    - `listItems(): { item: T; quantity: number }[]`.  
    - `getTotalValue(): number` (somando `item.getPrice() * quantity`).

- Uso obrigatório de generics com tipos diferentes:
  1. `Inventory<SingleProduct>` (apenas produtos simples).  
  2. `Inventory<Bundle>` (apenas pacotes).  
  3. `Inventory<PricedItem>` ou `Inventory<SingleProduct | Bundle>` (misto).

- Exemplo de uso:
  - Crie alguns `SingleProduct`.  
  - Crie alguns `Bundle` combinando esses produtos.  
  - Configure `Bundle.globalDiscount`.  
  - Preencha os três inventários e compare o resultado de `getTotalValue()` em cada um.
